#include "Patcher.h"

int main(int argc, char** argv) {
    /* Checking if the program is run without parameters */
    if (argc != 2) {
        info("Usage: %s <PID>\n", argv[0]);
        return EXIT_FAILURE;
    }

    DWORD PID = atoi(argv[1]);
    ok("Retrieved the PID! Beginning DLL injection...\n\t-->\tPID: %lu", PID);

    info("Trying to get a handle to the process...");
    HANDLE hProcess = OpenProcess(PROCESS_CREATE_THREAD | PROCESS_VM_OPERATION | PROCESS_VM_WRITE, FALSE, PID);

    if (hProcess == NULL) {
        error("Failed to get a handle to the process...\n\t-->\tError: 0x%X", GetLastError());

        return EXIT_FAILURE;
    }

    ok("Got a handle to the process!\n\t-->\tHandle: 0x%p", hProcess);
    info("Trying to allocate memory to the process...");

    LPVOID lpRemotePath = VirtualAllocEx(hProcess, NULL, MAX_PATH * sizeof(wchar_t), MEM_COMMIT, PAGE_READWRITE);
    if (lpRemotePath == NULL) {
        error("Failed to get allocate memory...\n\t-->\tError: 0x%X", GetLastError());

        return EXIT_FAILURE;
    }

    ok("Allocated the memory to the process!");

    wchar_t szDllPath[MAX_PATH];
    GetFullPathNameW(L"C:\\Users\\chry\\source\\repos\\Debug_patcher\\x64\\Release\\NaitDLL.dll", MAX_PATH, szDllPath, NULL);

    info("Trying to write the memory...");

    SIZE_T bytes = NULL;
    
    if (!WriteProcessMemory(hProcess, lpRemotePath, szDllPath, (wcslen(szDllPath) + 1) * sizeof(wchar_t), &bytes)) {
        error("Failed to write memory to the process...\n\t-->\tError: 0x%X", GetLastError());

        return EXIT_FAILURE;
    }

    ok("Memory to the process written successfully!\n\t-->\tBytes written: %zu", bytes);
    info("Trying to get a handle to the kernel32.dll library...");

    HMODULE hKernel32 = GetModuleHandle(L"kernel32.dll");
    if (hKernel32 == NULL) {
        error("Failed to get a handle to the kernel32.dll...\n\t-->\tError: 0x%X", GetLastError());

        return EXIT_FAILURE;
    }

    ok("Got the handle to the kernel32.dll!\n\t-->\tHandle: 0x%p", hKernel32);
    info("Trying to load the LoadLibraryW function...");

    FARPROC lpLoadLibraryW = GetProcAddress(hKernel32, "LoadLibraryW");
    if (lpLoadLibraryW == NULL) {
        error("Failed to the adress to the LoadLibraryW function...\n\t-->\tError: 0x%X", GetLastError());

        return EXIT_FAILURE;
    }

    ok("LoadLibraryW loaded succesfully!");
    info("Trying to create a remote thread (and begin the injection...)");

    HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)lpLoadLibraryW, lpRemotePath, 0, NULL);
    if (hThread == NULL) {
        error("Failed to create the thread...\n\t-->\tError: 0x%X", GetLastError());

        return EXIT_FAILURE;
    }

    ok("Thread created successully!");

    WaitForSingleObject(hThread, INFINITE);

    info("Freeing the allocated memory, closing the handles and exiting...");
    VirtualFreeEx(hProcess, lpRemotePath, 0, MEM_RELEASE);
    CloseHandle(hThread);
    CloseHandle(hProcess);

    return EXIT_SUCCESS;
}